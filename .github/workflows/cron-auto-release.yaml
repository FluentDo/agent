name: Tag a new release
on:
  schedule:
    - cron: "0 10 * * 1"
  workflow_dispatch:
jobs:
  find-last-good:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    outputs:
      sha: ${{ steps.get-commit.outputs.sha }}
    steps:
      - uses: actions/checkout@v5
        with:
          # check out the entire repo history for SHA verification
          fetch-depth: 0

      - name: Find matching workflow
        uses: SamhammerAG/last-successful-build-action@v7
        id: get-commit
        with:
          token: "${{ secrets.GITHUB_TOKEN }}"
          branch: "main"
          workflow: "Build and test"
          verify: true

  create-tag:
    name: Create tag
    runs-on: ubuntu-latest
    needs:
      - find-last-good
    permissions:
      contents: write
      id-token: write
    outputs:
      tag_name: ${{ steps.tag_name.outputs.tag_name }}
      next_tag: ${{ steps.tag_name.outputs.next_tag }}
    steps:
      - name: Authenticate with GCP
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: "projects/841522437311/locations/global/workloadIdentityPools/github-actions/providers/github-actions"
          service_account: "terraform-infra@infrastructure-464010.iam.gserviceaccount.com"

      - id: get-secrets
        name: Get secrets from GCP Secret Manager
        # This step retrieves secrets from GCP Secret Manager and sets them as outputs
        # The secrets can then be accessed in subsequent steps using ${{ steps.get-secrets.outputs.<secret_name> }}
        uses: "google-github-actions/get-secretmanager-secrets@v3"
        with:
          secrets: |-
            github-pat:projects/626836145334/secrets/GITHUB_CI_PAT

      - uses: actions/checkout@v5
        with:
          ref: ${{ needs.find-last-good.outputs.sha }}
          # The tag must be pushed using a PAT to ensure workflows then run.
          token: ${{ steps.get-secrets.outputs.github-pat }}
          # We need tags present to check for them
          fetch-tags: true

      - name: Tag name
        id: tag_name
        run: |
          # Create a tag name based on the current date
          # Format: vYY.M.W
          YEAR=$(date +%y)
          MONTH=$(date +%-m)
          WEEK=$((($(date +%-d)-1)/7+1))
          echo "tag_name=v${YEAR}.${MONTH}.${WEEK}"
          echo "tag_name=v${YEAR}.${MONTH}.${WEEK}" >> $GITHUB_OUTPUT

          NEXT_WEEK=$((WEEK + 1))
          # Ignore 5 week months
          if [ $NEXT_WEEK -gt 4 ]; then
            NEXT_WEEK=1
            MONTH=$((MONTH + 1))
            if [ $MONTH -gt 12 ]; then
            MONTH=1
            YEAR=$((YEAR + 1))
            fi
          fi
          echo "next_tag=v${YEAR}.${MONTH}.${NEXT_WEEK}"
          echo "next_tag=v${YEAR}.${MONTH}.${NEXT_WEEK}" >> $GITHUB_OUTPUT
        shell: bash

      - name: Check if tag already exists
        run: |
          # Check if the tag already exists on the remote
          if git ls-remote --exit-code --tags origin "$TAG_NAME" >/dev/null; then
            echo "Tag $TAG_NAME already exists. Exiting."
            git ls-remote --tags
            exit 1
          fi
        shell: bash
        env:
          TAG_NAME: ${{ steps.tag_name.outputs.tag_name }}

      # The tag must be pushed using a PAT to ensure workflows then run.
      - name: Create tag
        run: |
          git tag ${{ steps.tag_name.outputs.tag_name }}
          git push origin ${{ steps.tag_name.outputs.tag_name }}
        shell: bash
